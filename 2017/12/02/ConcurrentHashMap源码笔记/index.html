<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="kiyo,jixusen@yahoo.co.jp"><title>ConcurrentHashMap源码笔记（龟速更新中） · kiyo's Blog</title><meta name="description" content="ConcurrentHashMap源码笔记主要特性

1.ConcurrentHashMap支持完全并发的检索操作以及较高并发的更新操作。本类遵循同HashTable类一样的机能规格，针对HashTable的各个方法都有对应版本的实现。另外，尽管本类的所有操作都是线程安全的，查询操作并不会导致锁定，"><meta name="keywords" content="Spring,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/myblog/css/style.css"><link rel="stylesheet" href="/myblog/css/blog_basic.css"><link rel="stylesheet" href="/myblog/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/myblog/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/myblog">kiyo's Blog</a></h3><div class="description"><p>菜鸟程序员日常.</p></div></div></div><ul class="social-links"></ul><div class="footer"><a href="/myblog">kiyo 2017<div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Published with Hexo&#65281;</a></div></a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/myblog">首页</a></li><li><a href="/myblog/about">关于</a></li><li><a href="/myblog/archives">归档</a></li><li><a href="/myblog/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/myblog/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>ConcurrentHashMap源码笔记（龟速更新中）</a></h3></div><div class="post-content"><h1 id="ConcurrentHashMap源码笔记"><a href="#ConcurrentHashMap源码笔记" class="headerlink" title="ConcurrentHashMap源码笔记"></a>ConcurrentHashMap源码笔记</h1><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><blockquote>
<ul>
<li>1.ConcurrentHashMap支持完全并发的检索操作以及较高并发的更新操作。本类遵循同HashTable类一样的机能规格，针对HashTable的各个方法都有对应版本的实现。另外，尽管本类的所有操作都是线程安全的，查询操作并不会导致锁定，也不支持加锁整张表来阻止任何访问。当仅关心线程安全而不是具体的同步机制时本类可以完全兼容HashTable。</li>
<li>2.检索操作(包括get)通常不会阻塞，因此可能会和更新操作(包括put和remove)部分重叠。检索操作会反映与其相关的最近一次更新操作结果。(换句话说，一次对指定key的更新操作happens-before任何(非null)通过同样key获取到更新后value的检索操作)。</li>
<li>3.诸如putAll和remove这样的聚合操作，并发的检索操作可能只能反映部分新增和移除结果。类似的，Iterators, Spliterators 以及 Enumerations 返回的元素仅反映iterator/enumeration创建时或创建后哈希表某一时刻的状态。</li>
<li>4.需要注意的是，诸如size, isEmpty这样的聚合状态方法以及containsValue方法返回的都是某个时刻的状态，因此只能用来作为检测或评估之用，而不应该作为程序中的控制条件使用。</li>
</ul>
</blockquote>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>ConcurrentHashMap提供了无参，可以指定初始容量/负载因子/并发级别(并发更新线程数)，以及以Map实例作为入参的构造器。每个构造器的具体特性参考下面的注释。<br><strong>需要注意的是，作为入参传入的负载因子只会影响实际初始容量的大小</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认的初始容量(16)来创建一个空map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定初始容量来创建一个空map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 如果指定初始容量&gt;=最大容量的1/2就以最大容量作为初始容量</span></span><br><span class="line">    <span class="comment">// 否则就已&gt;=并且最接近(指定初始容量 + 指定初始容量/2 + 1)的2的幂值作为初始容量</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// sizeCtl变量作为触发下次扩容的临界值</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个与指定map实例拥有相同mapping的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定初始容量，负载因子，以及默认的并发级别(1)创建一个空map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定初始容量，负载因子，以及并发级别创建一个空map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 保证初始容量至少比并发更新线程数大</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>Node – 键/值映射</p>
<blockquote>
<p>1.本类不支持对value的修改，适用于只读遍历。<br>2.哈希值为负数的子类有特殊用途，如TreeNode,ForwardingNode等。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 哈希值</span></span><br><span class="line"><span class="keyword">final</span> K key; <span class="comment">// 键</span></span><br><span class="line"><span class="keyword">volatile</span> V val; <span class="comment">// 值 volatile保证值总是最新的</span></span><br><span class="line"><span class="keyword">volatile</span> Node&lt;K,V&gt; next; <span class="comment">// 下一节点 volatile保证next的变化总是能立即反映</span></span><br></pre></td></tr></table></figure>
<h4 id="重要方法-构造器"><a href="#重要方法-构造器" class="headerlink" title="重要方法/构造器"></a>重要方法/构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不支持value修改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find方法默认实现，在子类中重写</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            K ek;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>ForwardingNode – 临时转发节点</p>
<blockquote>
<p>1.本类是Node类的一个特殊子类，哈希值固定-1，仅存在于扩容过程中。<br>2.插入该节点代表原table的节点已经移动至新的table，新table通过.nextTable获取。<br>3.遍历操作过程中发现此类型节点会使遍历操作转发至新table，put操作过程中发现此类型节点则可以协助扩容。</p>
</blockquote>
<h4 id="内部变量-1"><a href="#内部变量-1" class="headerlink" title="内部变量"></a>内部变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable; <span class="comment">// 指向新table -- final修饰保证指向一经确定不会改变</span></span><br></pre></td></tr></table></figure>
<h4 id="重要方法-构造器-1"><a href="#重要方法-构造器-1" class="headerlink" title="重要方法/构造器"></a>重要方法/构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了哈希值固定-1以外，其它实例域都为null</span></span><br><span class="line">ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">    <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写父类的find方法，会基于新table执行查找操作</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">    outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 先检查table或者table指定下标是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> eh; K ek;</span><br><span class="line">            <span class="comment">// 当前节点符合条件则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="comment">// 哈希值&lt;0代表特殊节点，需要根据节点类型区分操作</span></span><br><span class="line">            <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="comment">// 再次遇到临时转发节点，将查找操作转发至新table，否则调用节点类型对应find方法。</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                    <span class="keyword">continue</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Traverser</p>
<blockquote>
<p>1.本类为ConcurrnetHashMap的一些方法提供遍历支持，例如ContainsValue，同时也是其它iterator和spliterator的基类。<br>2.通常，遍历操作是挨个桶执行的。但是如果发生了扩容操作，那就需要遍历新table中的两个桶，分别是下标为当前index的桶和下标为index+baseSize的桶。这是因为table扩容后会重新计算原桶中元素的下标，这会使部分元素被分配到index+baseSize的桶中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Traverser</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="内部变量-2"><a href="#内部变量-2" class="headerlink" title="内部变量"></a>内部变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab;        <span class="comment">// 当前遍历的table，扩容时会更新</span></span><br><span class="line">Node&lt;K,V&gt; next;         <span class="comment">// 下一节点</span></span><br><span class="line">TableStack&lt;K,V&gt; stack, spare; <span class="comment">// 遇到ForwardingNode时保存/恢复原table</span></span><br><span class="line"><span class="keyword">int</span> index;              <span class="comment">// 下一个桶的位置</span></span><br><span class="line"><span class="keyword">int</span> baseIndex;          <span class="comment">// table初始index</span></span><br><span class="line"><span class="keyword">int</span> baseLimit;          <span class="comment">// table初始index上限</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> baseSize;     <span class="comment">// table初始大小</span></span><br></pre></td></tr></table></figure>
<h4 id="重要方法-构造器-2"><a href="#重要方法-构造器-2" class="headerlink" title="重要方法/构造器"></a>重要方法/构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取下一个节点元素，如果遇到ForwardingNode会保存当前遍历的table信息，并在完成新table指定位置遍历后恢复之前保存的table信息。 </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 尝试获取下一节点</span></span><br><span class="line">    <span class="keyword">if</span> ((e = next) != <span class="keyword">null</span>)</span><br><span class="line">        e = e.next;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t; <span class="keyword">int</span> i, n;  <span class="comment">// must use locals in checks</span></span><br><span class="line">        <span class="comment">// 获取到非null节点则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> next = e;</span><br><span class="line">        <span class="comment">// 边界检验--如果当前遍历的table为空或者已经完成遍历则直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (baseIndex &gt;= baseLimit || (t = tab) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = t.length) &lt;= (i = index) || i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 尝试获取接下来需要遍历的桶</span></span><br><span class="line">        <span class="comment">// 如果桶非空并且桶内存放的是特殊节点则进行特殊处理    </span></span><br><span class="line">        <span class="keyword">if</span> ((e = tabAt(t, i)) != <span class="keyword">null</span> &amp;&amp; e.hash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">// 如果桶内存放了ForwardingNode，则保存当前遍历table状态并将遍历操作转发到新table</span></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                e = <span class="keyword">null</span>;</span><br><span class="line">                pushState(t, i, n);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="comment">// 如果桶内存放了TreeBin，则获取红黑树链表形式的头节点进行遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeBin)</span><br><span class="line">                e = ((TreeBin&lt;K,V&gt;)e).first;</span><br><span class="line">        	<span class="comment">// 其它节点(ReservationNode)，没有实际数据</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// table遍历状态保存栈不为空，则尝试出栈操作，前提是已经遍历玩当前table的两个桶</span></span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>)</span><br><span class="line">            recoverState(n);</span><br><span class="line">        <span class="comment">// 标记下一个需要遍历的桶下标，在当前桶遍历完成之后才会用到新的index</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((index = i + baseSize) &gt;= n)</span><br><span class="line">            index = ++baseIndex; <span class="comment">// visit upper slots if present</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当获取到ForwardingNode时保存当前遍历table状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushState</span><span class="params">(Node&lt;K,V&gt;[] t, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 如果spare不为null，则复用为栈顶</span></span><br><span class="line">    TableStack&lt;K,V&gt; s = spare;  <span class="comment">// reuse if possible</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        spare = s.next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s = <span class="keyword">new</span> TableStack&lt;K,V&gt;();</span><br><span class="line">    <span class="comment">// 保存当前table的遍历状态会执行入栈操作</span></span><br><span class="line">    s.tab = t;</span><br><span class="line">    s.length = n;</span><br><span class="line">    s.index = i;</span><br><span class="line">    s.next = stack;</span><br><span class="line">    stack = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试恢复上一次保存的table遍历状态，前提是已经完成当前table两个桶的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    TableStack&lt;K,V&gt; s; <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// index += (len = s.length)) &gt;= n 表示当前table没有下一个需要遍历的桶了</span></span><br><span class="line">    <span class="keyword">while</span> ((s = stack) != <span class="keyword">null</span> &amp;&amp; (index += (len = s.length)) &gt;= n) &#123;</span><br><span class="line">    <span class="comment">// 恢复栈顶保存的table遍历状态，并将出栈元素保存在spare中以便复用</span></span><br><span class="line">        n = len;</span><br><span class="line">        index = s.index;</span><br><span class="line">        tab = s.tab;</span><br><span class="line">        s.tab = <span class="keyword">null</span>;</span><br><span class="line">        TableStack&lt;K,V&gt; next = s.next;</span><br><span class="line">        s.next = spare; <span class="comment">// save for reuse</span></span><br><span class="line">        stack = next;</span><br><span class="line">        spare = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记下一个需要遍历的桶下标，在当前桶遍历完成之后才会用到新的index</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; (index += baseSize) &gt;= n)</span><br><span class="line">        index = ++baseIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="检索方法"><a href="#检索方法" class="headerlink" title="检索方法"></a>检索方法</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>由于ConcurrentHashMap不支持null作为key/value，返回null即表示不存在指定key对应的value，这一点和HashMap不同。下面先贴一下整体代码，再逐步分析具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面对get方法源码做一下简单的分析:</p>
<p>首先看内部方法spread，主要是一些位操作，目的是使数据更分散，减少碰撞。<br>因为在插入元素时会调用spread方法对key的哈希值进行处理，因此检索元素时也需要调用本方法来保证一致性。</p>
<ul>
<li>1.将h的高16位和低16位作异或操作，兼顾高位和低位数据来增加结果的随机性以减少碰撞发生。如果没有这一步操作，在哈希表长度较小时，通过哈希值和数组长度计算下标的操作将不会利用高位数据，这样就可能会增加数据碰撞的几率。</li>
<li>– h ^ (h &gt;&gt;&gt; 16)</li>
<li>2.将操作1的结果和0x7fffffff做与操作置最高位为0，保证结果一定是整数。这是因为负数值有特殊的用途(比如ForwardingNode的哈希值固定为-1)</li>
<li>– (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>接着是针对哈希表的一些判断，首先检查哈希表是否不为空，接着看key哈希值(处理后)对应的数组下标是否存在mapping元素。如果两者都不满足，就直接返回null。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">   (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<p>最后就是在对应下标查找元素的过程了。代码如下:<br>首先会检查当前下标对应的首节点是否就是要找的节点，是就直接返回首节点。<br>接着判断首节点hash值，hash值<0说明是特殊节点(treenode,forwardingnode..)，需要调用对应的find方法查找节点，hash值>=0则说明是链表节点，直接遍历查找。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">      <span class="keyword">return</span> e.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 特殊节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 链表节点  </span></span><br><span class="line"><span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">      ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">      <span class="keyword">return</span> e.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></0说明是特殊节点(treenode,forwardingnode..)，需要调用对应的find方法查找节点，hash值></p>
<h4 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h4><p>该方法直接调用get方法并判断其返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h4><p>该方法需要遍历整个map，效率会比containsKey慢很多(根据key查找可以根据哈希值直接命中对应的哈希表下标，查找范围会小很多)。<br>这里重点关注内部类Traverser<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    <span class="keyword">if</span> ((t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Traverser&lt;K,V&gt; it = <span class="keyword">new</span> Traverser&lt;K,V&gt;(t, t.length, <span class="number">0</span>, t.length);</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; p; (p = it.advance()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">if</span> ((v = p.val) == value || (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-02</span><i class="fa fa-tag"></i><a href="/myblog/tags/Java-Collections-Framework/" title="Java Collections Framework" class="tag">Java Collections Framework </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://blog.kiyo.top/2017/12/02/ConcurrentHashMap源码笔记/,kiyo's Blog,ConcurrentHashMap源码笔记（龟速更新中）,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/myblog/2017/12/06/Spring设计模式应用之适配器模式/" title="Spring设计模式应用之适配器模式" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/myblog/2017/12/02/ConcurrentMap源码笔记/" title="ConcurrentMap源码笔记" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/myblog/js/jquery.js"></script><script src="/myblog/js/jquery-migrate-1.2.1.min.js"></script><script src="/myblog/js/jquery.appear.js"></script></body></html>